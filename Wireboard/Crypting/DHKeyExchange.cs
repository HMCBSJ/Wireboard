using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Agreement;
using Org.BouncyCastle.Crypto.Digests;
using Org.BouncyCastle.Crypto.Generators;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.Security;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Wireboard.Crypting
{
    class DHKeyExchange
    {
        // Pregenerated DHParams (known to the remote client already), g = 2
        private static byte[] DH2048_P = new byte[]
        {
            0x95,0x73,0x2C,0xD8,0x20,0x83,0x57,0x75,0xC3,0xE5,0xD9,0xF8,
            0xE9,0xC0,0x02,0x9E,0x9B,0xAB,0xB1,0xE3,0x7E,0x81,0xF0,0xFA,
            0x4F,0xE5,0x80,0x15,0xDD,0x2A,0x53,0x03,0x3D,0x9E,0x4D,0x0B,
            0x9A,0xB7,0x35,0x6C,0xA5,0xE0,0x4D,0x7B,0x1D,0x6C,0xF2,0x09,
            0x63,0xFA,0xE2,0x19,0x1F,0xC4,0x81,0x26,0xF8,0xB8,0xB1,0xC2,
            0x9E,0xDE,0x68,0x12,0xDF,0xD2,0x73,0x8E,0x96,0xC4,0xF4,0x80,
            0xF9,0x36,0x6C,0xEC,0x11,0xB1,0xCB,0xA4,0x67,0x2B,0x9E,0xD5,
            0x65,0xCD,0x38,0x74,0xFB,0x18,0xA2,0xEE,0x76,0x86,0x07,0x5C,
            0x4D,0xE5,0xB8,0x00,0x42,0x13,0x36,0xCD,0xC0,0x39,0x15,0xB6,
            0x65,0x13,0xEA,0x1D,0x47,0xC4,0x49,0xBC,0x86,0x43,0x8E,0xBE,
            0x7E,0x4D,0xFB,0x20,0xC4,0xE1,0xD6,0x16,0x2F,0xDE,0x88,0xEE,
            0xCB,0xE3,0x09,0xB7,0x07,0xFD,0xEF,0xD1,0x63,0xA1,0xE0,0x14,
            0x17,0xFE,0x2E,0x22,0x6E,0x11,0xA8,0x43,0x95,0x8F,0x62,0xE8,
            0xA0,0x6B,0x59,0xA4,0x34,0xEF,0x52,0xE8,0xFC,0x89,0x46,0x77,
            0xF1,0x90,0x57,0x92,0x86,0xCC,0x7A,0x5E,0x10,0x7C,0xA5,0x55,
            0xFD,0x35,0xB2,0xCE,0x71,0xBB,0x8F,0xDC,0x43,0xFC,0x69,0x58,
            0x46,0x2E,0xCC,0x90,0x16,0xE7,0x31,0xCF,0x00,0x30,0x48,0xA8,
            0x23,0x28,0xD2,0x3B,0x36,0x3E,0xE9,0x78,0x8D,0x7C,0x49,0xE6,
            0x12,0xFE,0x64,0x4E,0xF1,0x0E,0xA9,0x60,0xDA,0x6F,0x64,0xA3,
            0xAF,0xE8,0xAE,0xA0,0x8C,0x8F,0x3C,0x72,0x9E,0xB0,0x4E,0x67,
            0x59,0xF1,0xD6,0xB4,0xDC,0xFB,0x91,0x09,0x2B,0x2C,0x08,0x6F,
            0x7D,0xB5,0xBD,0xE3,
        };

        private bool m_bInited = false;
        private DHParameters m_dhParameters;
        private AsymmetricCipherKeyPair m_keyPair;
        public byte[] SharedSecret { get; private set; }

        private void Init()
        {
            m_dhParameters = new DHParameters(new BigInteger(1, DH2048_P), BigInteger.Two);
            KeyGenerationParameters keyGenerationParameters = new DHKeyGenerationParameters(new SecureRandom(), m_dhParameters);
            DHBasicKeyPairGenerator dhKeyPairGenerator = new DHBasicKeyPairGenerator();
            dhKeyPairGenerator.Init(keyGenerationParameters);
            m_keyPair = dhKeyPairGenerator.GenerateKeyPair();
            m_bInited = true;

        }

        public byte[] GetPublicKey()
        {
            if (!m_bInited)
                Init();
            return ((DHPublicKeyParameters)m_keyPair.Public).Y.ToByteArrayUnsigned();
        }

        public byte[] CalculateSharedSecret(byte[] remotePublicKey)
        {
            if (!m_bInited)
                Init();
            DHPublicKeyParameters remoteKeyParameters = new DHPublicKeyParameters(new BigInteger(1, remotePublicKey), m_dhParameters);
            DHBasicAgreement agreement = new DHBasicAgreement();
            agreement.Init(m_keyPair.Private);
            byte[] resAgreement = agreement.CalculateAgreement(remoteKeyParameters).ToByteArrayUnsigned();

            Sha256Digest digest = new Sha256Digest();
            byte[] resHash = new byte[digest.GetDigestSize()];
            digest.BlockUpdate(resAgreement, 0, resAgreement.Length);
            digest.DoFinal(resHash, 0);

            SharedSecret = resHash;
            return resHash;
        }
    }
}
